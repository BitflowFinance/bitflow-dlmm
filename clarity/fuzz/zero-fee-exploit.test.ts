import {
  alice,
  deployer,
  dlmmCore,
  sbtcUsdcPool,
  mockSbtcToken,
  mockUsdcToken,
  setupTokens,
  generateBinFactors,
} from "../tests/helpers/helpers";

import { describe, it, expect, beforeEach } from 'vitest';
import { txOk, rovOk } from '@clarigen/test';
import { LogManager, SeededRandom, DirectionType } from './utils';

interface PoolState {
  activeBinId: bigint;
  binXBalance: bigint;
  binYBalance: bigint;
  initialPrice: bigint;
  binStep: bigint;
}

interface SwapResult {
  swapNumber: number;
  direction: DirectionType;
  inputAmount: bigint;
  actualOutput: bigint;
  expectedInteger: bigint;
  expectedFloat: bigint;
  userFavored: bigint;
  poolFavored: bigint;
  floatDiff: bigint;
  floatPercentDiff: number;
  poolValueBefore: bigint;
  poolValueAfter: bigint;
  activeBinXBefore: bigint;
  activeBinYBefore: bigint;
  activeBinXAfter: bigint;
  activeBinYAfter: bigint;
}

interface CumulativeResults {
  totalSwaps: number;
  totalUserFavored: bigint;
  totalPoolFavored: bigint;
  totalFloatDiff: bigint;
  maxFloatPercentDiff: number;
  totalTokensExtracted: bigint;
  expectedTokensExtractableFloat: bigint;
  excessExtraction: bigint;
  initialPoolValue: bigint;
  finalPoolValue: bigint;
  poolValueChange: bigint;
  swaps: SwapResult[];
}

interface DrainResult {
  drained: boolean;
  swapsToDrain: number;
  totalTokensExtracted: bigint;
  expectedExtractableFloat: bigint;
  totalUserFavored: bigint;
  totalPoolFavored: bigint;
  excessExtraction: bigint;
  finalBinX: bigint;
  finalBinY: bigint;
  swaps: SwapResult[];
}

class TestConfig {
  static readonly FEE_SCALE_BPS = 10000n;
  static readonly PRICE_SCALE_BPS = 100000000n;
  
  // Pool creation parameters
  static readonly INITIAL_X_AMOUNT = 10000000n; // 0.1 BTC
  static readonly INITIAL_Y_AMOUNT = 5000000000n; // 5000 USDC
  static readonly BURN_AMOUNT = 1000n;
  static readonly BIN_STEP = 25n;
  static readonly VARIABLE_FEES_COOLDOWN = 900n;
  
  // Test parameters
  static readonly SWAP_AMOUNT = 1000n;
  static readonly SWAP_AMOUNT_JITTER = 0.50; // Â±50% jitter
  static readonly REPEATED_SWAP_COUNT = 100;
  static readonly MAX_DRAIN_SWAPS = 1000;
  static readonly RANDOM_SEED = 42;
  
  // Fee settings for Phase 2
  static readonly PROTOCOL_FEE_BPS = 10n; // 0.1%
  static readonly PROVIDER_FEE_BPS = 30n; // 0.3%
}

class PoolManager {
  /**
   * Create a pool with zero fees for exploit testing
   */
  static createZeroFeePool(): void {
    setupTokens();
    
    // Register bin-step if not already registered
    const currentBinSteps = rovOk(dlmmCore.getBinSteps());
    if (!currentBinSteps.includes(TestConfig.BIN_STEP)) {
      const factors = generateBinFactors();
      txOk(dlmmCore.addBinStep(TestConfig.BIN_STEP, factors), deployer);
    }
    
    txOk(dlmmCore.createPool(
      sbtcUsdcPool.identifier,
      mockSbtcToken.identifier,
      mockUsdcToken.identifier,
      TestConfig.INITIAL_X_AMOUNT,
      TestConfig.INITIAL_Y_AMOUNT,
      TestConfig.BURN_AMOUNT,
      0n, 0n, // x fees
      0n, 0n, // y fees
      TestConfig.BIN_STEP,
      TestConfig.VARIABLE_FEES_COOLDOWN,
      false, // freeze variable fees manager
      null, // dynamic-config
      deployer, // fee address
      "https://bitflow.finance/dlmm",
      true // status
    ), deployer);
  }

  static setFees(xProtocolFee: bigint, xProviderFee: bigint, yProtocolFee: bigint, yProviderFee: bigint): void {
    txOk(dlmmCore.setXFees(sbtcUsdcPool.identifier, xProtocolFee, xProviderFee), deployer);
    txOk(dlmmCore.setYFees(sbtcUsdcPool.identifier, yProtocolFee, yProviderFee), deployer);
  }

  static getState(): PoolState {
    const poolData = rovOk(sbtcUsdcPool.getPool())!;
    const activeBinId = poolData.activeBinId;
    const unsignedBinId = rovOk(dlmmCore.getUnsignedBinId(activeBinId))!;
    const binBalances = rovOk(sbtcUsdcPool.getBinBalances(unsignedBinId))!;
    
    return {
      activeBinId,
      binXBalance: binBalances.xBalance,
      binYBalance: binBalances.yBalance,
      initialPrice: poolData.initialPrice,
      binStep: poolData.binStep,
    };
  }
}

class SwapCalculator {
  static getBinPrice(initialPrice: bigint, binStep: bigint, binId: bigint): bigint {
    return rovOk(dlmmCore.getBinPrice(initialPrice, binStep, binId))!;
  }

  static calculatePoolValue(poolState: PoolState): bigint {
    const binPrice = this.getBinPrice(poolState.initialPrice, poolState.binStep, poolState.activeBinId);
    return (poolState.binXBalance * binPrice) / TestConfig.PRICE_SCALE_BPS + poolState.binYBalance;
  }

  static calculateExpectedOutput(
    inputAmount: bigint,
    direction: DirectionType,
    poolState: PoolState,
    hasFees: boolean
  ): { expectedInteger: bigint; expectedFloat: bigint } {
    const binPrice = this.getBinPrice(poolState.initialPrice, poolState.binStep, poolState.activeBinId);
    
    if (direction === 'x-for-y') {
      return this.calculateXForY(inputAmount, binPrice, poolState, hasFees);
    } else {
      return this.calculateYForX(inputAmount, binPrice, poolState, hasFees);
    }
  }

  private static calculateXForY(
    inputAmount: bigint,
    binPrice: bigint,
    poolState: PoolState,
    hasFees: boolean
  ): { expectedInteger: bigint; expectedFloat: bigint } {
    // Float calculation
    const maxXAmountFloat = (Number(poolState.binYBalance) * Number(TestConfig.PRICE_SCALE_BPS)) / Number(binPrice);
    
    let updatedMaxXAmountFloat = maxXAmountFloat;
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const swapFeeTotal = Number(poolData.xProtocolFee || 0n) + Number(poolData.xProviderFee || 0n) + Number(poolData.xVariableFee || 0n);
      if (swapFeeTotal > 0) {
        updatedMaxXAmountFloat = (maxXAmountFloat * Number(TestConfig.FEE_SCALE_BPS)) / (Number(TestConfig.FEE_SCALE_BPS) - swapFeeTotal);
      }
    }
    
    const actualInputFloat = Math.min(Number(inputAmount), updatedMaxXAmountFloat);
    let actualInputEffectiveFloat = actualInputFloat;
    
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const swapFeeTotal = Number(poolData.xProtocolFee || 0n) + Number(poolData.xProviderFee || 0n) + Number(poolData.xVariableFee || 0n);
      if (swapFeeTotal > 0) {
        actualInputEffectiveFloat = actualInputFloat - ((actualInputFloat * swapFeeTotal) / Number(TestConfig.FEE_SCALE_BPS));
      }
    }
    
    const expectedDyFloat = (actualInputEffectiveFloat * Number(binPrice)) / Number(TestConfig.PRICE_SCALE_BPS);
    const expectedDyFloatCapped = Math.min(expectedDyFloat, Number(poolState.binYBalance));
    
    // int calculation
    const maxXAmountInteger = (poolState.binYBalance * TestConfig.PRICE_SCALE_BPS + (binPrice - 1n)) / binPrice;
    
    let updatedMaxXAmountInteger = maxXAmountInteger;
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const swapFeeTotal = (poolData.xProtocolFee || 0n) + (poolData.xProviderFee || 0n) + (poolData.xVariableFee || 0n);
      if (swapFeeTotal > 0n) {
        // updated-max = (max-amount * FEE_SCALE_BPS) / (FEE_SCALE_BPS - swap-fee-total)
        updatedMaxXAmountInteger = (maxXAmountInteger * TestConfig.FEE_SCALE_BPS) / (TestConfig.FEE_SCALE_BPS - swapFeeTotal);
      }
    }
    
    const actualInputInteger = inputAmount < updatedMaxXAmountInteger ? inputAmount : updatedMaxXAmountInteger;
    
    let effectiveAmountInteger = actualInputInteger;
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const swapFeeTotal = (poolData.xProtocolFee || 0n) + (poolData.xProviderFee || 0n) + (poolData.xVariableFee || 0n);
      if (swapFeeTotal > 0n) {
        const fees = (actualInputInteger * swapFeeTotal) / TestConfig.FEE_SCALE_BPS;
        effectiveAmountInteger = actualInputInteger - fees;
      }
    }
    
    const expectedDyInteger = (effectiveAmountInteger * binPrice) / TestConfig.PRICE_SCALE_BPS;
    const expectedDyIntegerCapped = expectedDyInteger > poolState.binYBalance ? poolState.binYBalance : expectedDyInteger;
    
    return {
      expectedInteger: expectedDyIntegerCapped,
      expectedFloat: BigInt(Math.floor(expectedDyFloatCapped)),
    };
  }

  private static calculateYForX(
    inputAmount: bigint,
    binPrice: bigint,
    poolState: PoolState,
    hasFees: boolean
  ): { expectedInteger: bigint; expectedFloat: bigint } {
    const maxYAmountFloat = (Number(poolState.binXBalance) * Number(binPrice)) / Number(TestConfig.PRICE_SCALE_BPS);
    
    let updatedMaxYAmountFloat = maxYAmountFloat;
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const swapFeeTotal = Number(poolData.yProtocolFee || 0n) + Number(poolData.yProviderFee || 0n) + Number(poolData.yVariableFee || 0n);
      if (swapFeeTotal > 0) {
        updatedMaxYAmountFloat = (maxYAmountFloat * Number(TestConfig.FEE_SCALE_BPS)) / (Number(TestConfig.FEE_SCALE_BPS) - swapFeeTotal);
      }
    }
    
    const actualInputFloat = Math.min(Number(inputAmount), updatedMaxYAmountFloat);
    let actualInputEffectiveFloat = actualInputFloat;
    
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const swapFeeTotal = Number(poolData.yProtocolFee || 0n) + Number(poolData.yProviderFee || 0n) + Number(poolData.yVariableFee || 0n);
      if (swapFeeTotal > 0) {
        actualInputEffectiveFloat = actualInputFloat - ((actualInputFloat * swapFeeTotal) / Number(TestConfig.FEE_SCALE_BPS));
      }
    }
    
    const expectedDxFloat = (actualInputEffectiveFloat * Number(TestConfig.PRICE_SCALE_BPS)) / Number(binPrice);
    const expectedDxFloatCapped = Math.min(expectedDxFloat, Number(poolState.binXBalance));
    
    const maxYAmountInteger = (poolState.binXBalance * binPrice + (TestConfig.PRICE_SCALE_BPS - 1n)) / TestConfig.PRICE_SCALE_BPS;
    
    let updatedMaxYAmountInteger = maxYAmountInteger;
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const swapFeeTotal = (poolData.yProtocolFee || 0n) + (poolData.yProviderFee || 0n) + (poolData.yVariableFee || 0n);
      if (swapFeeTotal > 0n) {
        // updated-max = (max-amount * FEE_SCALE_BPS) / (FEE_SCALE_BPS - swap-fee-total)
        updatedMaxYAmountInteger = (maxYAmountInteger * TestConfig.FEE_SCALE_BPS) / (TestConfig.FEE_SCALE_BPS - swapFeeTotal);
      }
    }
    
    const actualInputInteger = inputAmount < updatedMaxYAmountInteger ? inputAmount : updatedMaxYAmountInteger;
    
    let effectiveAmountInteger = actualInputInteger;
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const swapFeeTotal = (poolData.yProtocolFee || 0n) + (poolData.yProviderFee || 0n) + (poolData.yVariableFee || 0n);
      if (swapFeeTotal > 0n) {
        const fees = (actualInputInteger * swapFeeTotal) / TestConfig.FEE_SCALE_BPS;
        effectiveAmountInteger = actualInputInteger - fees;
      }
    }
    
    const expectedDxInteger = (effectiveAmountInteger * TestConfig.PRICE_SCALE_BPS) / binPrice;
    const expectedDxIntegerCapped = expectedDxInteger > poolState.binXBalance ? poolState.binXBalance : expectedDxInteger;
    
    return {
      expectedInteger: expectedDxIntegerCapped,
      expectedFloat: BigInt(Math.floor(expectedDxFloatCapped)),
    };
  }

  static measureRoundingDifference(
    actualOutput: bigint,
    expectedFloat: bigint
  ): { userFavored: bigint; poolFavored: bigint; totalDiff: bigint; percentDiff: number } {
    const diff = actualOutput > expectedFloat ? actualOutput - expectedFloat : expectedFloat - actualOutput;
    const userFavored = actualOutput > expectedFloat ? diff : 0n;
    const poolFavored = actualOutput < expectedFloat ? diff : 0n;
    const percentDiff = actualOutput > 0n ? (Number(diff) / Number(actualOutput)) * 100 : 0;
    
    return { userFavored, poolFavored, totalDiff: diff, percentDiff };
  }
}

class SwapExecutor {
  static execute(direction: DirectionType, amount: bigint, swapNumber: number, hasFees: boolean): SwapResult {
    const beforeState = PoolManager.getState();
    const poolValueBefore = SwapCalculator.calculatePoolValue(beforeState);
    const expected = SwapCalculator.calculateExpectedOutput(amount, direction, beforeState, hasFees);
    
    const actualOutput = direction === 'x-for-y'
      ? this.executeXForY(amount, beforeState.activeBinId)
      : this.executeYForX(amount, beforeState.activeBinId);
    
    const afterState = PoolManager.getState();
    const poolValueAfter = SwapCalculator.calculatePoolValue(afterState);
    const rounding = SwapCalculator.measureRoundingDifference(actualOutput, expected.expectedFloat);
    
    return {
      swapNumber,
      direction,
      inputAmount: amount,
      actualOutput,
      expectedInteger: expected.expectedInteger,
      expectedFloat: expected.expectedFloat,
      userFavored: rounding.userFavored,
      poolFavored: rounding.poolFavored,
      floatDiff: rounding.totalDiff,
      floatPercentDiff: rounding.percentDiff,
      poolValueBefore,
      poolValueAfter,
      activeBinXBefore: beforeState.binXBalance,
      activeBinYBefore: beforeState.binYBalance,
      activeBinXAfter: afterState.binXBalance,
      activeBinYAfter: afterState.binYBalance,
    };
  }

  private static executeXForY(amount: bigint, activeBinId: bigint): bigint {
    const result = txOk(dlmmCore.swapXForY(
      sbtcUsdcPool.identifier,
      mockSbtcToken.identifier,
      mockUsdcToken.identifier,
      Number(activeBinId),
      amount
    ), alice);
    return result.value.out;
  }

  private static executeYForX(amount: bigint, activeBinId: bigint): bigint {
    const result = txOk(dlmmCore.swapYForX(
      sbtcUsdcPool.identifier,
      mockSbtcToken.identifier,
      mockUsdcToken.identifier,
      Number(activeBinId),
      amount
    ), alice);
    return result.value.out;
  }
}

class TestOrchestrator {
  static performRepeatedSwaps(
    count: number,
    baseAmount: bigint, 
    direction: DirectionType, 
    hasFees: boolean,
    orchestrator: LogManager
  ): CumulativeResults {
    const initialState = PoolManager.getState();
    const initialPoolValue = SwapCalculator.calculatePoolValue(initialState);
    const rng = new SeededRandom(TestConfig.RANDOM_SEED);
    
    const swaps: SwapResult[] = [];
    let totalUserFavored = 0n;
    let totalPoolFavored = 0n;
    let totalFloatDiff = 0n;
    let maxFloatPercentDiff = 0;
    let totalTokensExtracted = 0n;
    let expectedTokensExtractableFloat = 0n;
    
    orchestrator.log(`Starting repeated swaps: ${count} x ${direction} (fees: ${hasFees})`);
    
    for (let i = 0; i < count; i++) {
     orchestrator.updateProgress(i + 1, count);
      
      // Apply jitter to swap amount
      const jitteredAmount = rng.applyJitter(baseAmount, TestConfig.SWAP_AMOUNT_JITTER);
      const swapResult = SwapExecutor.execute(direction, jitteredAmount, i + 1, hasFees);
      swaps.push(swapResult);
      
      totalUserFavored += swapResult.userFavored;
      totalPoolFavored += swapResult.poolFavored;
      totalFloatDiff += swapResult.floatDiff;
      if (swapResult.floatPercentDiff > maxFloatPercentDiff) {
        maxFloatPercentDiff = swapResult.floatPercentDiff;
      }
      totalTokensExtracted += swapResult.actualOutput;
      expectedTokensExtractableFloat += swapResult.expectedFloat;
    }
    
    const finalState = PoolManager.getState();
    const finalPoolValue = SwapCalculator.calculatePoolValue(finalState);
    const excessExtraction = totalTokensExtracted > expectedTokensExtractableFloat
      ? totalTokensExtracted - expectedTokensExtractableFloat
      : 0n;
    
    const results = {
      totalSwaps: count,
      totalUserFavored,
      totalPoolFavored,
      totalFloatDiff,
      maxFloatPercentDiff,
      totalTokensExtracted,
      expectedTokensExtractableFloat,
      excessExtraction,
      initialPoolValue,
      finalPoolValue,
      poolValueChange: finalPoolValue - initialPoolValue,
      swaps,
    };
    
    return results;
  }

  static testActiveBinDrain(
    baseSwapAmount: bigint, 
    direction: DirectionType, 
    maxSwaps: number, 
    hasFees: boolean,
    orchestrator: LogManager
  ): DrainResult {
    const rng = new SeededRandom(TestConfig.RANDOM_SEED);
    const swaps: SwapResult[] = [];
    let swapCount = 0;
    let totalTokensExtracted = 0n;
    let expectedExtractableFloat = 0n;
    let totalUserFavored = 0n;
    let totalPoolFavored = 0n;
    
    orchestrator.log(`Starting drain test: ${direction} (fees: ${hasFees})`);

    while (swapCount < maxSwaps) {
      const currentState = PoolManager.getState();
      
      // Check if bin is drained
      if ((direction === 'x-for-y' && currentState.binYBalance === 0n) ||
          (direction === 'y-for-x' && currentState.binXBalance === 0n)) {
        break;
      }
      
      orchestrator.updateProgress(swapCount, maxSwaps, `X: ${currentState.binXBalance} | Y: ${currentState.binYBalance}`);
      
      // Apply jitter to swap amount
      const jitteredAmount = rng.applyJitter(baseSwapAmount, TestConfig.SWAP_AMOUNT_JITTER);
      const swapResult = SwapExecutor.execute(direction, jitteredAmount, swapCount + 1, hasFees);
      swaps.push(swapResult);
      
      totalTokensExtracted += swapResult.actualOutput;
      expectedExtractableFloat += swapResult.expectedFloat;
      totalUserFavored += swapResult.userFavored;
      totalPoolFavored += swapResult.poolFavored;
      
      swapCount++;
    }
    
    const finalState = PoolManager.getState();
    const drained = (direction === 'x-for-y' && finalState.binYBalance === 0n) ||
                    (direction === 'y-for-x' && finalState.binXBalance === 0n);
    const excessExtraction = totalTokensExtracted > expectedExtractableFloat
      ? totalTokensExtracted - expectedExtractableFloat
      : 0n;
    
    return {
      drained,
      swapsToDrain: swapCount,
      totalTokensExtracted,
      expectedExtractableFloat,
      totalUserFavored,
      totalPoolFavored,
      excessExtraction,
      finalBinX: finalState.binXBalance,
      finalBinY: finalState.binYBalance,
      swaps,
    };
  }
}

describe('Zero-Fee Rounding Exploit Tests', () => {
  
  describe('Phase 1: Zero-Fee Tests', () => {
    beforeEach(() => {
      PoolManager.createZeroFeePool();
    });
    
    it('Should test if zero-fee repeated small swaps allow unfair token extraction (x-for-y)', async () => {
      const orchestrator = new LogManager('zero-fee-exploit-x-for-y');
      const results = TestOrchestrator.performRepeatedSwaps(
        TestConfig.REPEATED_SWAP_COUNT,
        TestConfig.SWAP_AMOUNT,
        'x-for-y',
        false,
        orchestrator
      );
      
      orchestrator.recordResult(results);
      orchestrator.finish();
      expect(results.totalFloatDiff).toBeDefined();
    }, 300000);
    
    it('Should test if zero-fee repeated small swaps allow unfair token extraction (y-for-x)', async () => {
      const orchestrator = new LogManager('zero-fee-exploit-y-for-x');
      const results = TestOrchestrator.performRepeatedSwaps(
        TestConfig.REPEATED_SWAP_COUNT,
        TestConfig.SWAP_AMOUNT,
        'y-for-x',
        false,
        orchestrator
      );
      
      orchestrator.recordResult(results);
      orchestrator.finish();
      expect(results.totalFloatDiff).toBeDefined();
    }, 300000);
    
    it('Should test if zero-fee swaps can drain active bin unfairly (x-for-y)', async () => {
      const orchestrator = new LogManager('zero-fee-drain-x-for-y');
      const result = TestOrchestrator.testActiveBinDrain(
        TestConfig.SWAP_AMOUNT,
        'x-for-y',
        TestConfig.MAX_DRAIN_SWAPS,
        false,
        orchestrator
      );
      
      orchestrator.recordResult(result);
      orchestrator.finish();
      expect(result.drained).toBeDefined();
    }, 600000);
    
    it('Should test if zero-fee swaps can drain active bin unfairly (y-for-x)', async () => {
      const orchestrator = new LogManager('zero-fee-drain-y-for-x');
      const result = TestOrchestrator.testActiveBinDrain(
        TestConfig.SWAP_AMOUNT,
        'y-for-x',
        TestConfig.MAX_DRAIN_SWAPS,
        false,
        orchestrator
      );
      
      orchestrator.recordResult(result);
      orchestrator.finish();
      expect(result.drained).toBeDefined();
    }, 600000);
  });
  
  describe('Phase 2: With Fees Tests', () => {
    beforeEach(() => {
      PoolManager.createZeroFeePool();
      PoolManager.setFees(
        TestConfig.PROTOCOL_FEE_BPS,
        TestConfig.PROVIDER_FEE_BPS,
        TestConfig.PROTOCOL_FEE_BPS,
        TestConfig.PROVIDER_FEE_BPS
      );
    });
    
    it('Should test if fees prevent unfair token extraction (x-for-y)', async () => {
      const orchestrator = new LogManager('with-fees-exploit-x-for-y');
      const results = TestOrchestrator.performRepeatedSwaps(
        TestConfig.REPEATED_SWAP_COUNT,
        TestConfig.SWAP_AMOUNT,
        'x-for-y',
        true,
        orchestrator
      );
      
      orchestrator.recordResult(results);
      orchestrator.finish();
      expect(results.totalFloatDiff).toBeDefined();
    }, 300000);
    
    it('Should test if fees prevent unfair token extraction (y-for-x)', async () => {
      const orchestrator = new LogManager('with-fees-exploit-y-for-x');
      const results = TestOrchestrator.performRepeatedSwaps(
        TestConfig.REPEATED_SWAP_COUNT,
        TestConfig.SWAP_AMOUNT,
        'y-for-x',
        true,
        orchestrator
      );
      
      orchestrator.recordResult(results);
      orchestrator.finish();
      expect(results.totalFloatDiff).toBeDefined();
    }, 300000);
    
    it('Should test if fees prevent active bin drain exploit (x-for-y)', async () => {
      const orchestrator = new LogManager('with-fees-drain-x-for-y');
      const result = TestOrchestrator.testActiveBinDrain(
        TestConfig.SWAP_AMOUNT,
        'x-for-y',
        TestConfig.MAX_DRAIN_SWAPS,
        true,
        orchestrator
      );
      
      orchestrator.recordResult(result);
      orchestrator.finish();
      expect(result.drained).toBeDefined();
    }, 600000);
    
    it('Should test if fees prevent active bin drain exploit (y-for-x)', async () => {
      const orchestrator = new LogManager('with-fees-drain-y-for-x');
      const result = TestOrchestrator.testActiveBinDrain(
        TestConfig.SWAP_AMOUNT,
        'y-for-x',
        TestConfig.MAX_DRAIN_SWAPS,
        true,
        orchestrator
      );
      
      orchestrator.recordResult(result);
      orchestrator.finish();
      expect(result.drained).toBeDefined();
    }, 600000);
  });
});
