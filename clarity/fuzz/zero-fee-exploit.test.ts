/**
 * Zero-Fee Rounding Exploit Test
 */

import {
  alice,
  deployer,
  dlmmCore,
  sbtcUsdcPool,
  mockSbtcToken,
  mockUsdcToken,
  setupTokens,
  generateBinFactors,
} from "../tests/helpers/helpers";

import { describe, it, expect, beforeEach } from 'vitest';
import { txOk, rovOk } from '@clarigen/test';
import * as fs from 'fs';
import * as path from 'path';

// ============================================================================
// Type Definitions
// ============================================================================

type Direction = 'x-for-y' | 'y-for-x';

interface PoolState {
  activeBinId: bigint;
  binXBalance: bigint;
  binYBalance: bigint;
  initialPrice: bigint;
  binStep: bigint;
}

interface SwapResult {
  swapNumber: number;
  direction: Direction;
  inputAmount: bigint;
  actualOutput: bigint;
  expectedInteger: bigint;
  expectedFloat: bigint;
  userFavored: bigint;
  poolFavored: bigint;
  floatDiff: bigint;
  floatPercentDiff: number;
  poolValueBefore: bigint;
  poolValueAfter: bigint;
  activeBinXBefore: bigint;
  activeBinYBefore: bigint;
  activeBinXAfter: bigint;
  activeBinYAfter: bigint;
}

interface CumulativeResults {
  totalSwaps: number;
  totalUserFavored: bigint;
  totalPoolFavored: bigint;
  totalFloatDiff: bigint;
  maxFloatPercentDiff: number;
  totalTokensExtracted: bigint;
  expectedTokensExtractableFloat: bigint;
  excessExtraction: bigint;
  initialPoolValue: bigint;
  finalPoolValue: bigint;
  poolValueChange: bigint;
  swaps: SwapResult[];
}

interface DrainResult {
  drained: boolean;
  swapsToDrain: number;
  totalTokensExtracted: bigint;
  expectedExtractableFloat: bigint;
  totalUserFavored: bigint;
  totalPoolFavored: bigint;
  excessExtraction: bigint;
  finalBinX: bigint;
  finalBinY: bigint;
  swaps: SwapResult[];
}

// ============================================================================
// Configuration & Constants
// ============================================================================

class TestConfig {
  static readonly FEE_SCALE_BPS = 10000n;
  static readonly PRICE_SCALE_BPS = 100000000n;
  
  // Pool creation parameters
  static readonly INITIAL_X_AMOUNT = 10000000n; // 0.1 BTC
  static readonly INITIAL_Y_AMOUNT = 5000000000n; // 5000 USDC
  static readonly BURN_AMOUNT = 1000n;
  static readonly BIN_STEP = 25n;
  static readonly VARIABLE_FEES_COOLDOWN = 900n;
  
  // Test parameters
  static readonly SWAP_AMOUNT = 1000n;
  static readonly SWAP_AMOUNT_JITTER = 0.50; // ±50% jitter
  static readonly REPEATED_SWAP_COUNT = 100;
  static readonly MAX_DRAIN_SWAPS = 1000;
  static readonly RANDOM_SEED = 42;
  
  // Progress bar settings
  static readonly PROGRESS_BAR_WIDTH = 30;
  static readonly PROGRESS_UPDATE_INTERVAL = 10;
  static readonly DRAIN_PROGRESS_UPDATE_INTERVAL = 100;
  
  // Fee settings for Phase 2
  static readonly PROTOCOL_FEE_BPS = 10n; // 0.1%
  static readonly PROVIDER_FEE_BPS = 30n; // 0.3%
}

// ============================================================================
// Seeded Random Number Generator
// ============================================================================

class SeededRandom {
  private seed: number;

  constructor(seed: number) {
    this.seed = seed;
  }

  next(): number {
    this.seed = (this.seed * 9301 + 49297) % 233280;
    return this.seed / 233280;
  }

  /**
   * Apply jitter to a bigint amount
   * Returns amount with ±jitter% variation
   */
  applyJitter(amount: bigint, jitterPercent: number): bigint {
    const minMultiplier = 1 - jitterPercent;
    const maxMultiplier = 1 + jitterPercent;
    const randomMultiplier = minMultiplier + (this.next() * (maxMultiplier - minMultiplier));
    const jitteredAmount = (amount * BigInt(Math.floor(randomMultiplier * 10000))) / 10000n;
    return jitteredAmount > 0n ? jitteredAmount : 1n;
  }
}

// ============================================================================
// Pool Manager
// ============================================================================

class PoolManager {
  /**
   * Create a pool with zero fees for exploit testing
   */
  static createZeroFeePool(): void {
    setupTokens();
    
    // Register bin-step if not already registered
    const currentBinSteps = rovOk(dlmmCore.getBinSteps());
    if (!currentBinSteps.includes(TestConfig.BIN_STEP)) {
      const factors = generateBinFactors();
      txOk(dlmmCore.addBinStep(TestConfig.BIN_STEP, factors), deployer);
    }
    
    // Create pool with all fees set to 0
    txOk(dlmmCore.createPool(
      sbtcUsdcPool.identifier,
      mockSbtcToken.identifier,
      mockUsdcToken.identifier,
      TestConfig.INITIAL_X_AMOUNT,
      TestConfig.INITIAL_Y_AMOUNT,
      TestConfig.BURN_AMOUNT,
      0n, 0n, // x fees (0% protocol, 0% provider)
      0n, 0n, // y fees (0% protocol, 0% provider)
      TestConfig.BIN_STEP,
      TestConfig.VARIABLE_FEES_COOLDOWN,
      false, // freeze variable fees manager
      null, // dynamic-config
      deployer, // fee address
      "https://bitflow.finance/dlmm",
      true // status
    ), deployer);
  }

  /**
   * Set pool fees to specified values
   */
  static setFees(xProtocolFee: bigint, xProviderFee: bigint, yProtocolFee: bigint, yProviderFee: bigint): void {
    txOk(dlmmCore.setXFees(sbtcUsdcPool.identifier, xProtocolFee, xProviderFee), deployer);
    txOk(dlmmCore.setYFees(sbtcUsdcPool.identifier, yProtocolFee, yProviderFee), deployer);
  }

  /**
   * Get current pool state
   */
  static getState(): PoolState {
    const poolData = rovOk(sbtcUsdcPool.getPool())!;
    const activeBinId = poolData.activeBinId;
    const unsignedBinId = rovOk(dlmmCore.getUnsignedBinId(activeBinId))!;
    const binBalances = rovOk(sbtcUsdcPool.getBinBalances(unsignedBinId))!;
    
    return {
      activeBinId,
      binXBalance: binBalances.xBalance,
      binYBalance: binBalances.yBalance,
      initialPrice: poolData.initialPrice,
      binStep: poolData.binStep,
    };
  }
}

// ============================================================================
// Swap Calculator
// ============================================================================

class SwapCalculator {
  /**
   * Get bin price from contract
   */
  static getBinPrice(initialPrice: bigint, binStep: bigint, binId: bigint): bigint {
    return rovOk(dlmmCore.getBinPrice(initialPrice, binStep, binId))!;
  }

  /**
   * Calculate pool value in Y token terms
   */
  static calculatePoolValue(poolState: PoolState): bigint {
    const binPrice = this.getBinPrice(poolState.initialPrice, poolState.binStep, poolState.activeBinId);
    return (poolState.binXBalance * binPrice) / TestConfig.PRICE_SCALE_BPS + poolState.binYBalance;
  }

  /**
   * Calculate expected output using float math
   */
  static calculateExpectedOutput(
    inputAmount: bigint,
    direction: Direction,
    poolState: PoolState,
    hasFees: boolean
  ): { expectedInteger: bigint; expectedFloat: bigint } {
    const binPrice = this.getBinPrice(poolState.initialPrice, poolState.binStep, poolState.activeBinId);
    
    if (direction === 'x-for-y') {
      return this.calculateXForY(inputAmount, binPrice, poolState, hasFees);
    } else {
      return this.calculateYForX(inputAmount, binPrice, poolState, hasFees);
    }
  }

  private static calculateXForY(
    inputAmount: bigint,
    binPrice: bigint,
    poolState: PoolState,
    hasFees: boolean
  ): { expectedInteger: bigint; expectedFloat: bigint } {
    // Float calculation (for reference/comparison)
    const maxXAmountFloat = (Number(poolState.binYBalance) * Number(TestConfig.PRICE_SCALE_BPS)) / Number(binPrice);
    
    let updatedMaxXAmountFloat = maxXAmountFloat;
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const swapFeeTotal = Number(poolData.xProtocolFee || 0n) + Number(poolData.xProviderFee || 0n) + Number(poolData.xVariableFee || 0n);
      if (swapFeeTotal > 0) {
        updatedMaxXAmountFloat = (maxXAmountFloat * Number(TestConfig.FEE_SCALE_BPS)) / (Number(TestConfig.FEE_SCALE_BPS) - swapFeeTotal);
      }
    }
    
    const actualInputFloat = Math.min(Number(inputAmount), updatedMaxXAmountFloat);
    let actualInputEffectiveFloat = actualInputFloat;
    
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const swapFeeTotal = Number(poolData.xProtocolFee || 0n) + Number(poolData.xProviderFee || 0n) + Number(poolData.xVariableFee || 0n);
      if (swapFeeTotal > 0) {
        actualInputEffectiveFloat = actualInputFloat - ((actualInputFloat * swapFeeTotal) / Number(TestConfig.FEE_SCALE_BPS));
      }
    }
    
    const expectedDyFloat = (actualInputEffectiveFloat * Number(binPrice)) / Number(TestConfig.PRICE_SCALE_BPS);
    const expectedDyFloatCapped = Math.min(expectedDyFloat, Number(poolState.binYBalance));
    
    // Integer calculation
    const maxXAmountInteger = (poolState.binYBalance * TestConfig.PRICE_SCALE_BPS + (binPrice - 1n)) / binPrice;
    
    let updatedMaxXAmountInteger = maxXAmountInteger;
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const swapFeeTotal = (poolData.xProtocolFee || 0n) + (poolData.xProviderFee || 0n) + (poolData.xVariableFee || 0n);
      if (swapFeeTotal > 0n) {
        // updated-max = (max-amount * FEE_SCALE_BPS) / (FEE_SCALE_BPS - swap-fee-total)
        updatedMaxXAmountInteger = (maxXAmountInteger * TestConfig.FEE_SCALE_BPS) / (TestConfig.FEE_SCALE_BPS - swapFeeTotal);
      }
    }
    
    // Step 3: Cap input amount to max
    const actualInputInteger = inputAmount < updatedMaxXAmountInteger ? inputAmount : updatedMaxXAmountInteger;
    
    let effectiveAmountInteger = actualInputInteger;
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const swapFeeTotal = (poolData.xProtocolFee || 0n) + (poolData.xProviderFee || 0n) + (poolData.xVariableFee || 0n);
      if (swapFeeTotal > 0n) {
        const fees = (actualInputInteger * swapFeeTotal) / TestConfig.FEE_SCALE_BPS;
        effectiveAmountInteger = actualInputInteger - fees;
      }
    }
    
    const expectedDyInteger = (effectiveAmountInteger * binPrice) / TestConfig.PRICE_SCALE_BPS;
    const expectedDyIntegerCapped = expectedDyInteger > poolState.binYBalance ? poolState.binYBalance : expectedDyInteger;
    
    return {
      expectedInteger: expectedDyIntegerCapped,
      expectedFloat: BigInt(Math.floor(expectedDyFloatCapped)),
    };
  }

  private static calculateYForX(
    inputAmount: bigint,
    binPrice: bigint,
    poolState: PoolState,
    hasFees: boolean
  ): { expectedInteger: bigint; expectedFloat: bigint } {
    const maxYAmountFloat = (Number(poolState.binXBalance) * Number(binPrice)) / Number(TestConfig.PRICE_SCALE_BPS);
    
    let updatedMaxYAmountFloat = maxYAmountFloat;
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const swapFeeTotal = Number(poolData.yProtocolFee || 0n) + Number(poolData.yProviderFee || 0n) + Number(poolData.yVariableFee || 0n);
      if (swapFeeTotal > 0) {
        updatedMaxYAmountFloat = (maxYAmountFloat * Number(TestConfig.FEE_SCALE_BPS)) / (Number(TestConfig.FEE_SCALE_BPS) - swapFeeTotal);
      }
    }
    
    const actualInputFloat = Math.min(Number(inputAmount), updatedMaxYAmountFloat);
    let actualInputEffectiveFloat = actualInputFloat;
    
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const swapFeeTotal = Number(poolData.yProtocolFee || 0n) + Number(poolData.yProviderFee || 0n) + Number(poolData.yVariableFee || 0n);
      if (swapFeeTotal > 0) {
        actualInputEffectiveFloat = actualInputFloat - ((actualInputFloat * swapFeeTotal) / Number(TestConfig.FEE_SCALE_BPS));
      }
    }
    
    const expectedDxFloat = (actualInputEffectiveFloat * Number(TestConfig.PRICE_SCALE_BPS)) / Number(binPrice);
    const expectedDxFloatCapped = Math.min(expectedDxFloat, Number(poolState.binXBalance));
    
    const maxYAmountInteger = (poolState.binXBalance * binPrice + (TestConfig.PRICE_SCALE_BPS - 1n)) / TestConfig.PRICE_SCALE_BPS;
    
    let updatedMaxYAmountInteger = maxYAmountInteger;
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const swapFeeTotal = (poolData.yProtocolFee || 0n) + (poolData.yProviderFee || 0n) + (poolData.yVariableFee || 0n);
      if (swapFeeTotal > 0n) {
        // updated-max = (max-amount * FEE_SCALE_BPS) / (FEE_SCALE_BPS - swap-fee-total)
        updatedMaxYAmountInteger = (maxYAmountInteger * TestConfig.FEE_SCALE_BPS) / (TestConfig.FEE_SCALE_BPS - swapFeeTotal);
      }
    }
    
    const actualInputInteger = inputAmount < updatedMaxYAmountInteger ? inputAmount : updatedMaxYAmountInteger;
    
    let effectiveAmountInteger = actualInputInteger;
    if (hasFees) {
      const poolData = rovOk(sbtcUsdcPool.getPool())!;
      const swapFeeTotal = (poolData.yProtocolFee || 0n) + (poolData.yProviderFee || 0n) + (poolData.yVariableFee || 0n);
      if (swapFeeTotal > 0n) {
        const fees = (actualInputInteger * swapFeeTotal) / TestConfig.FEE_SCALE_BPS;
        effectiveAmountInteger = actualInputInteger - fees;
      }
    }
    
    const expectedDxInteger = (effectiveAmountInteger * TestConfig.PRICE_SCALE_BPS) / binPrice;
    const expectedDxIntegerCapped = expectedDxInteger > poolState.binXBalance ? poolState.binXBalance : expectedDxInteger;
    
    return {
      expectedInteger: expectedDxIntegerCapped,
      expectedFloat: BigInt(Math.floor(expectedDxFloatCapped)),
    };
  }

  /**
   * Measure rounding difference between actual and expected
   */
  static measureRoundingDifference(
    actualOutput: bigint,
    expectedFloat: bigint
  ): { userFavored: bigint; poolFavored: bigint; totalDiff: bigint; percentDiff: number } {
    const diff = actualOutput > expectedFloat ? actualOutput - expectedFloat : expectedFloat - actualOutput;
    const userFavored = actualOutput > expectedFloat ? diff : 0n;
    const poolFavored = actualOutput < expectedFloat ? diff : 0n;
    const percentDiff = actualOutput > 0n ? (Number(diff) / Number(actualOutput)) * 100 : 0;
    
    return { userFavored, poolFavored, totalDiff: diff, percentDiff };
  }
}

// ============================================================================
// Swap Executor
// ============================================================================

class SwapExecutor {
  /**
   * Execute a single swap and return results
   */
  static execute(direction: Direction, amount: bigint, swapNumber: number, hasFees: boolean): SwapResult {
    const beforeState = PoolManager.getState();
    const poolValueBefore = SwapCalculator.calculatePoolValue(beforeState);
    const expected = SwapCalculator.calculateExpectedOutput(amount, direction, beforeState, hasFees);
    
    const actualOutput = direction === 'x-for-y'
      ? this.executeXForY(amount, beforeState.activeBinId)
      : this.executeYForX(amount, beforeState.activeBinId);
    
    const afterState = PoolManager.getState();
    const poolValueAfter = SwapCalculator.calculatePoolValue(afterState);
    const rounding = SwapCalculator.measureRoundingDifference(actualOutput, expected.expectedFloat);
    
    return {
      swapNumber,
      direction,
      inputAmount: amount,
      actualOutput,
      expectedInteger: expected.expectedInteger,
      expectedFloat: expected.expectedFloat,
      userFavored: rounding.userFavored,
      poolFavored: rounding.poolFavored,
      floatDiff: rounding.totalDiff,
      floatPercentDiff: rounding.percentDiff,
      poolValueBefore,
      poolValueAfter,
      activeBinXBefore: beforeState.binXBalance,
      activeBinYBefore: beforeState.binYBalance,
      activeBinXAfter: afterState.binXBalance,
      activeBinYAfter: afterState.binYBalance,
    };
  }

  private static executeXForY(amount: bigint, activeBinId: bigint): bigint {
    const result = txOk(dlmmCore.swapXForY(
      sbtcUsdcPool.identifier,
      mockSbtcToken.identifier,
      mockUsdcToken.identifier,
      Number(activeBinId),
      amount
    ), alice);
    return result.value.out;
  }

  private static executeYForX(amount: bigint, activeBinId: bigint): bigint {
    const result = txOk(dlmmCore.swapYForX(
      sbtcUsdcPool.identifier,
      mockSbtcToken.identifier,
      mockUsdcToken.identifier,
      Number(activeBinId),
      amount
    ), alice);
    return result.value.out;
  }
}

// ============================================================================
// Progress Reporter
// ============================================================================

class ProgressReporter {
  private static write(message: string): void {
    try {
      process.stdout.write(message);
    } catch (e) {
      // Fallback if process.stdout not available
      console.log(message);
    }
  }

  static updateRepeatedSwaps(current: number, total: number): void {
    if ((current % TestConfig.PROGRESS_UPDATE_INTERVAL === 0) || current === 1) {
      const percent = ((current / total) * 100).toFixed(1);
      const filled = Math.floor((current / total) * TestConfig.PROGRESS_BAR_WIDTH);
      const empty = TestConfig.PROGRESS_BAR_WIDTH - filled;
      const bar = '█'.repeat(filled) + '░'.repeat(empty);
      this.write(`\r  Progress: [${bar}] ${percent}% (${current}/${total} swaps)`);
    }
  }

  static updateDrainTest(current: number, max: number, state: PoolState): void {
    if ((current % TestConfig.DRAIN_PROGRESS_UPDATE_INTERVAL === 0) || current === 0) {
      const percent = max > 0 ? ((current / max) * 100).toFixed(1) : '0';
      const filled = max > 0 ? Math.floor((current / max) * TestConfig.PROGRESS_BAR_WIDTH) : 0;
      const empty = TestConfig.PROGRESS_BAR_WIDTH - filled;
      const bar = '█'.repeat(filled) + '░'.repeat(empty);
      this.write(`\r  Progress: [${bar}] ${percent}% | Swaps: ${current} | X: ${state.binXBalance} | Y: ${state.binYBalance}`);
    }
  }

  static complete(): void {
    this.write('\n');
  }
}

// ============================================================================
// Results Logger
// ============================================================================

class ResultsLogger {
  private static ensureLogDir(): string {
    const logDir = path.join(process.cwd(), 'logs', 'fuzz-test-results');
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
    return logDir;
  }

  static logCumulativeResults(results: CumulativeResults, testName: string): void {
    console.log(`\n${testName} Results:`);
    console.log(`Total swaps: ${results.totalSwaps}`);
    console.log(`Total user favored: ${results.totalUserFavored}`);
    console.log(`Total pool favored: ${results.totalPoolFavored}`);
    console.log(`Total float diff: ${results.totalFloatDiff}`);
    console.log(`Max float % diff: ${results.maxFloatPercentDiff.toFixed(4)}%`);
    console.log(`Total tokens extracted: ${results.totalTokensExtracted}`);
    console.log(`Expected extractable (float): ${results.expectedTokensExtractableFloat}`);
    console.log(`Excess extraction: ${results.excessExtraction}`);
    console.log(`Pool value change: ${results.poolValueChange}`);
    
    const logDir = this.ensureLogDir();
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = path.join(logDir, `${testName}-${timestamp}.json`);
    fs.writeFileSync(filename, JSON.stringify(results, (_, v) => typeof v === 'bigint' ? v.toString() : v, 2));
  }

  static logDrainResults(results: DrainResult, testName: string): void {
    console.log(`\n${testName} Results:`);
    console.log(`Drained: ${results.drained}`);
    console.log(`Swaps to drain: ${results.swapsToDrain}`);
    console.log(`Total tokens extracted: ${results.totalTokensExtracted}`);
    console.log(`Expected extractable (float): ${results.expectedExtractableFloat}`);
    console.log(`Total user favored: ${results.totalUserFavored}`);
    console.log(`Total pool favored: ${results.totalPoolFavored}`);
    console.log(`Excess extraction: ${results.excessExtraction}`);
    console.log(`Final bin X: ${results.finalBinX}`);
    console.log(`Final bin Y: ${results.finalBinY}`);
    
    const logDir = this.ensureLogDir();
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = path.join(logDir, `${testName}-${timestamp}.json`);
    fs.writeFileSync(filename, JSON.stringify(results, (_, v) => typeof v === 'bigint' ? v.toString() : v, 2));
  }
}

// ============================================================================
// Test Orchestrator
// ============================================================================

class TestOrchestrator {
  /**
   * Perform repeated swaps with jittered amounts to track cumulative impact.
   */
  static performRepeatedSwaps(count: number, baseAmount: bigint, direction: Direction, hasFees: boolean): CumulativeResults {
    const initialState = PoolManager.getState();
    const initialPoolValue = SwapCalculator.calculatePoolValue(initialState);
    const rng = new SeededRandom(TestConfig.RANDOM_SEED);
    
    const swaps: SwapResult[] = [];
    let totalUserFavored = 0n;
    let totalPoolFavored = 0n;
    let totalFloatDiff = 0n;
    let maxFloatPercentDiff = 0;
    let totalTokensExtracted = 0n;
    let expectedTokensExtractableFloat = 0n;
    
    for (let i = 0; i < count; i++) {
      ProgressReporter.updateRepeatedSwaps(i + 1, count);
      
      // Apply jitter to swap amount
      const jitteredAmount = rng.applyJitter(baseAmount, TestConfig.SWAP_AMOUNT_JITTER);
      const swapResult = SwapExecutor.execute(direction, jitteredAmount, i + 1, hasFees);
      swaps.push(swapResult);
      
      totalUserFavored += swapResult.userFavored;
      totalPoolFavored += swapResult.poolFavored;
      totalFloatDiff += swapResult.floatDiff;
      if (swapResult.floatPercentDiff > maxFloatPercentDiff) {
        maxFloatPercentDiff = swapResult.floatPercentDiff;
      }
      totalTokensExtracted += swapResult.actualOutput;
      expectedTokensExtractableFloat += swapResult.expectedFloat;
    }
    
    ProgressReporter.complete();
    
    const finalState = PoolManager.getState();
    const finalPoolValue = SwapCalculator.calculatePoolValue(finalState);
    const excessExtraction = totalTokensExtracted > expectedTokensExtractableFloat
      ? totalTokensExtracted - expectedTokensExtractableFloat
      : 0n;
    
    return {
      totalSwaps: count,
      totalUserFavored,
      totalPoolFavored,
      totalFloatDiff,
      maxFloatPercentDiff,
      totalTokensExtracted,
      expectedTokensExtractableFloat,
      excessExtraction,
      initialPoolValue,
      finalPoolValue,
      poolValueChange: finalPoolValue - initialPoolValue,
      swaps,
    };
  }

  /**
   * Test if active bin can be drained unfairly.
   */
  static testActiveBinDrain(baseSwapAmount: bigint, direction: Direction, maxSwaps: number, hasFees: boolean): DrainResult {
    const rng = new SeededRandom(TestConfig.RANDOM_SEED);
    const swaps: SwapResult[] = [];
    let swapCount = 0;
    let totalTokensExtracted = 0n;
    let expectedExtractableFloat = 0n;
    let totalUserFavored = 0n;
    let totalPoolFavored = 0n;
    
    while (swapCount < maxSwaps) {
      const currentState = PoolManager.getState();
      
      // Check if bin is drained
      if ((direction === 'x-for-y' && currentState.binYBalance === 0n) ||
          (direction === 'y-for-x' && currentState.binXBalance === 0n)) {
        break;
      }
      
      ProgressReporter.updateDrainTest(swapCount, maxSwaps, currentState);
      
      // Apply jitter to swap amount
      const jitteredAmount = rng.applyJitter(baseSwapAmount, TestConfig.SWAP_AMOUNT_JITTER);
      const swapResult = SwapExecutor.execute(direction, jitteredAmount, swapCount + 1, hasFees);
      swaps.push(swapResult);
      
      totalTokensExtracted += swapResult.actualOutput;
      expectedExtractableFloat += swapResult.expectedFloat;
      totalUserFavored += swapResult.userFavored;
      totalPoolFavored += swapResult.poolFavored;
      
      swapCount++;
    }
    
    ProgressReporter.complete();
    
    const finalState = PoolManager.getState();
    const drained = (direction === 'x-for-y' && finalState.binYBalance === 0n) ||
                    (direction === 'y-for-x' && finalState.binXBalance === 0n);
    const excessExtraction = totalTokensExtracted > expectedExtractableFloat
      ? totalTokensExtracted - expectedExtractableFloat
      : 0n;
    
    return {
      drained,
      swapsToDrain: swapCount,
      totalTokensExtracted,
      expectedExtractableFloat,
      totalUserFavored,
      totalPoolFavored,
      excessExtraction,
      finalBinX: finalState.binXBalance,
      finalBinY: finalState.binYBalance,
      swaps,
    };
  }
}

// ============================================================================
// Test Suite
// ============================================================================

describe('Zero-Fee Rounding Exploit Tests', () => {
  
  describe('Phase 1: Zero-Fee Tests', () => {
    beforeEach(() => {
      PoolManager.createZeroFeePool();
    });
    
    it('Should test if zero-fee repeated small swaps allow unfair token extraction (x-for-y)', async () => {
      const results = TestOrchestrator.performRepeatedSwaps(
        TestConfig.REPEATED_SWAP_COUNT,
        TestConfig.SWAP_AMOUNT,
        'x-for-y',
        false
      );
      
      ResultsLogger.logCumulativeResults(results, 'zero-fee-exploit-x-for-y');
      expect(results.totalFloatDiff).toBeDefined();
    }, 300000);
    
    it('Should test if zero-fee repeated small swaps allow unfair token extraction (y-for-x)', async () => {
      const results = TestOrchestrator.performRepeatedSwaps(
        TestConfig.REPEATED_SWAP_COUNT,
        TestConfig.SWAP_AMOUNT,
        'y-for-x',
        false
      );
      
      ResultsLogger.logCumulativeResults(results, 'zero-fee-exploit-y-for-x');
      expect(results.totalFloatDiff).toBeDefined();
    }, 300000);
    
    it('Should test if zero-fee swaps can drain active bin unfairly (x-for-y)', async () => {
      const result = TestOrchestrator.testActiveBinDrain(
        TestConfig.SWAP_AMOUNT,
        'x-for-y',
        TestConfig.MAX_DRAIN_SWAPS,
        false
      );
      
      ResultsLogger.logDrainResults(result, 'zero-fee-drain-x-for-y');
      expect(result.drained).toBeDefined();
    }, 600000);
    
    it('Should test if zero-fee swaps can drain active bin unfairly (y-for-x)', async () => {
      const result = TestOrchestrator.testActiveBinDrain(
        TestConfig.SWAP_AMOUNT,
        'y-for-x',
        TestConfig.MAX_DRAIN_SWAPS,
        false
      );
      
      ResultsLogger.logDrainResults(result, 'zero-fee-drain-y-for-x');
      expect(result.drained).toBeDefined();
    }, 600000);
  });
  
  describe('Phase 2: With Fees Tests', () => {
    beforeEach(() => {
      PoolManager.createZeroFeePool();
      PoolManager.setFees(
        TestConfig.PROTOCOL_FEE_BPS,
        TestConfig.PROVIDER_FEE_BPS,
        TestConfig.PROTOCOL_FEE_BPS,
        TestConfig.PROVIDER_FEE_BPS
      );
    });
    
    it('Should test if fees prevent unfair token extraction (x-for-y)', async () => {
      const results = TestOrchestrator.performRepeatedSwaps(
        TestConfig.REPEATED_SWAP_COUNT,
        TestConfig.SWAP_AMOUNT,
        'x-for-y',
        true
      );
      
      ResultsLogger.logCumulativeResults(results, 'with-fees-exploit-x-for-y');
      expect(results.totalFloatDiff).toBeDefined();
    }, 300000);
    
    it('Should test if fees prevent unfair token extraction (y-for-x)', async () => {
      const results = TestOrchestrator.performRepeatedSwaps(
        TestConfig.REPEATED_SWAP_COUNT,
        TestConfig.SWAP_AMOUNT,
        'y-for-x',
        true
      );
      
      ResultsLogger.logCumulativeResults(results, 'with-fees-exploit-y-for-x');
      expect(results.totalFloatDiff).toBeDefined();
    }, 300000);
    
    it('Should test if fees prevent active bin drain exploit (x-for-y)', async () => {
      const result = TestOrchestrator.testActiveBinDrain(
        TestConfig.SWAP_AMOUNT,
        'x-for-y',
        TestConfig.MAX_DRAIN_SWAPS,
        true
      );
      
      ResultsLogger.logDrainResults(result, 'with-fees-drain-x-for-y');
      expect(result.drained).toBeDefined();
    }, 600000);
    
    it('Should test if fees prevent active bin drain exploit (y-for-x)', async () => {
      const result = TestOrchestrator.testActiveBinDrain(
        TestConfig.SWAP_AMOUNT,
        'y-for-x',
        TestConfig.MAX_DRAIN_SWAPS,
        true
      );
      
      ResultsLogger.logDrainResults(result, 'with-fees-drain-y-for-x');
      expect(result.drained).toBeDefined();
    }, 600000);
  });
});
